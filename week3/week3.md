# STEP week3

---

### 宿題1　modularized_calculator1.py
> モジュール化されたプログラムを変更して、「*」「/」に対応しよう

##### アルゴリズム
`evaluate`で計算する際に、式を2段階で評価することで「 * 」「 / 」と「 + 」「 - 」の優先度を扱った。

1回目の評価では、「 * 」「 / 」の部分だけを先に計算し、数字 * 数字、数字 / 数字 の部分を計算結果に置き換えるようにした。
こうすることで、1回目の評価をし終わった状態ではすべて「 + 」と「 - 」だけの計算式となる。

このあとは、2回目の評価で元のプログラムどおりに「 + 」「 - 」の計算を行うことで正しい計算結果が得られる。

##### 実行結果
```
$ python3 modularized_calculator1.py
==== Test started! ====
PASS! (1 = 1.000000)
PASS! (1+2 = 3.000000)
PASS! (1.0+2 = 3.000000)
PASS! (1.0+2.0 = 3.000000)
PASS! (1.0+2.1-3 = 0.100000)
PASS! (3.0+4*2-1/5 = 10.800000)
PASS! (3+4.0*2-1.0/5 = 10.800000)
PASS! (3.0+4.0*2.0-1.0/5.0 = 10.800000)
PASS! (3.0*4-5-10.0/2 = 2.000000)
==== Test finished! ====
```

---

### 宿題3　modularized_calculator2.py
> モジュール化されたプログラムを変更して、括弧に対応しよう

##### アルゴリズム
宿題1と同様に、式を何段階かに分けて評価することで () の優先度を扱うようにした。

**最も内側の(...計算式...)の中身を計算して、(...計算式...)の部分をその計算結果に置き換える　という作業を()がなくなるまで何回も繰り返し...①**、`evaluate`で計算結果を得る という方針で実装した。


* `found_inside_brackets` : ()が複数ある場合、一番内側の()から計算する必要があるため、一番内側の'('と')'の位置を返す

    indexメソッドを使って')'の位置を探した後、')'の位置から順に前方向に見ていき、最初に見つかったものを'('の位置とする


* `evaluate_inside_brackets` : ①

    `found_inside_brackets`で得た()の位置でスライスしたtokensリストを`evaluate`に渡して計算してもらい、**()内の計算結果...②** を得る

    スライスを使って()内の複数の要素を②に入れ替える

##### 実行結果
```
$ python3 modularized_calculator2.py
==== Test started! ====
PASS! (1 = 1.000000)
PASS! (1+2 = 3.000000)
PASS! (1.0+2 = 3.000000)
PASS! (1.0+2.0 = 3.000000)
PASS! (1.0+2.1-3 = 0.100000)
PASS! (3.0+4*2-1/5 = 10.800000)
PASS! (3+4.0*2-1.0/5 = 10.800000)
PASS! (3.0+4.0*2.0-1.0/5.0 = 10.800000)
PASS! (3.0*4-5-10.0/2 = 2.000000)
PASS! ((3.0+4*(2-1))/5 = 1.400000)
PASS! ((3.0+4.0*(2-1))/5 = 1.400000)
PASS! ((3.0+4.0*(2-1.0))/5 = 1.400000)
PASS! ((3.0+4.0*(2.0-1.0))/5.0 = 1.400000)
PASS! (((3*4+2)/2)*1.5 = 10.500000)
PASS! (3.0+((2*1.5)/3.0) = 4.000000)
==== Test finished! ====
```
